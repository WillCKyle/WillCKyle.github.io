<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
                border-radius: 16px;
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 16px;
                border-radius: 8px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                
                outline: 0;
                background: #E8D8FF;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 16px;
                border-radius: 8px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #E8D8FF;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #E8D8FF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p><p>The password is in my resume.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="View Case Study" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0121a235191fc9526e789df9b58d854317cfd95e3c5b80df292a4d7c3095cd17ce28081f7019404b52312410d580b04a11bd7aea102c6b33cde856297d93341716718577b62d876a569e702f4f88ad2b72c09ed6d6026e9020ec9d893a26285dad0a25b63966dbcfdc58d267b14550b3f22045a996a49e5eeb2d127fa2fb25928da5e10be05b2cb4d6b2e6884d946d1c39865b028e73cb2555975e8026f292cd11c60b4205ea41e144f953244718576014d615c326c1dcebe43e2e666bd03e88ed79a1d3b2f0304740cffb978f2e0859102965d3328e0d338a444f389ffe1101607b9a012643c5694d4b8a82c2654c06d3c1b9c83bc15156425565613e7c40fa26e3bee74afe5515ef91b298a3bd23ebc28711aac4f66307c95ea7dfb038751e8106071700cd88852ecf40f149f33aa1bdace56cf6a1c292d19040d7bf6994f43e93bc4551a8af9e15253865328304d0fe6ce9dde19b17f93034c94051249228461bac1f70f61cc89e6a3c3932e4b5662c4a0a9c121dc0525c4e7c24ea8bdd1c566173e7a9c97e7462e6815defd1793342700bc2339cf90e6f19cfcc07aa3924efb86b6a056f033b47dbe2de96b917e71dbaa747ba0bf5f3281814563def5425adc6e507f50b587de24c0082184d3104c7f2b719ffbefb9faa5548405670f32bff35d6127fdbb1245212c6b6fb0b5966a769d4e60df33f479bea367b16ce51f679e090a6f13622821eecf76b4bbe34efbb5fb9dff5ccfddb2c26b7313e985994913c24edf84fff15eea3566cba6a0380d2e5c1e46757d1894819aa9d00c79bddb3ff982d707c182d90267a7801753d815660dc38aa367918aeff6cbe611cb84fbb31025d706a5752505dcd348a88a93f89183d18fba2efcf7c811abe72aaff9b248907992cb67c4c260bd64f840db47a271becfe05d819e05c6e77c620f9a74e98b368c9321437ebbb387cd4130d9294541c047c414c3db5670a8c81d098fd90fa57678ec358bf756b45684092ea224255f0b85e6b6a0aa38f3bc3fee92ae55ae6da6f90e6cc2f2f6b565151736fa8f64ce686d5ef98f73f3fa3eb2afd8d4c92cf27dea2e0ac072b49e3b43194c1ce2cbd6a75e1552679006d24be1635a6caba1373fa866ba1023e9bafa44691794b7ed28819b76d33781a72ab9d04c22ac82a06e95ba0195d2b5584ad15e03127821af2dd0a111185b61541ad292543e62e2a1143f6a90720f923a9d49298f0eabff66b7e19f0f4dd5fe44996f30eb455ad7190d58f7f1c0d751db2356a583ecde67a36374f95ac06fb6ebb6eeb8bb2daad0555c864a9ae1a2d64643f768d3066eda0f7758479c05236f74a767a48869141603c9bdfd2541b5a305f300602ab4ca291f84020a583e5345a32764bd239ec279bf64cfdcb92137dcfda89a97c45125e61865f72a75589ac7959b566a04ddc7d9c49a3c0ff08b87edf5849914a564545e4913fa5f069b07afbb18ced3bd3ccf8d5f738a1417acc628445667b7f2b39e12c1e4527b69fa1e77eb18cdb91cc2839d569acc1f549a9d43ee538b4f23461fc77b0c1e1d95c21e5b932bcb49d26c6af82525ba2d06963cc072162cb9265cc741a9a4337f628a750f0e2fa5546116c0f910ecb683a3f016f8b58753bc44f8ef2cf744454f47e502b2c70fb623f6c8a9e2bba1e16a2a61a3ac31b8b16d1f4968ca62716a9a1fa6e5146984efb8d985aad24681a49cce83b49bd89d61b7ddcaf96c2fc939f19f49922470470ddf729d3312221d4d4444f84c08beb5cd6fd89e5c8a6b37c5c91f798a1d0193e7527590df8ff81c9be8197db4bb8ce64f60e3def55662c9297b52073f16f794e75fa7172a052f14389df89d6b5b714c5bd12d970416a5c0c19b647fda9870e7b1e8a8570e467ea58e50041a4b45b628768fde3cbee27301211230e355203fb50cca7a48e33d1515aff89c03ccb9f3c4c79d460292c9427e282d83047526d956b558f10f5954c4468a384f2caa5fbff014aabe198b155c673fa6bdc8591ce96c200135d3a6d1fc68291735482679379a3978d1532d27e1729aca8623c5589d5fb06fe116d4a311284516285a89c8545092724601a22de80868b9b52d2b856af7c19c5a3111f333719a0c873a259fd00acfb2c69456bcf6bf877a80ca97688005aef1fb41afca5a59fc6802cf0d198eee26bf99653edf80fa295150a7d2b5c7b30ca16f9fa46e9ec5f2733d2dc0fd9ad0dc347cbb1704685cfcafdbc8ccfbdf2ddbe93e2601ef019688c75ba9a77ca7d5b92c3cdfa7c2f70f35f50d94e85707779158699c4fc968d7dfb551e46a7f14ab063d950b84d06450f88b21ab5a2accb1a00aa67caab559e071edccb13f042a87afe616ebb2576c8139125c35d09088be06a5ccaf67f6d36aed628048ad82e441b530a2c2017981805a7a9fc1ec6e9cc4f58c409e5a5346ec183b616f3cc97b5df56ed824ef933861e46643ee57cd9c9f5e31e550f68db83ed79e0075883b92183c84088286d5882b7bd015d84e7daf4a8583ae398f96d20f87d7fbc36ba7adbb327c4b3bb2e141cd23d5d1ada0fd2094f86473781fbb82f56ccae7ad486285cc4e8862c4b3788c41b9f446d2c778c587ed51d27bee804f0b1a7c0b99d6e1dbde8ac304e0ba892299fe65b62037e4c947fc3700daef5e5c2c4350e43839f6b5d5927c6014b183213a8f07888036127d57d125497c9e6344b5f79a9c6f907050f4a89474aa3836b964ba29b483b81537f8b9b0fd06b2be367384424e4d3bbf2525bdb0b18c7708cae2374dd2394c6153e5da2c474c94992bfaf78cb4b4d4bc49a3f6e059a8d6e143fd17dd39d2354a68044ca455c7c990b925fc6e93cfc7ca9709aa6d2de396540d599ac55b3dd6ac41f6d41afc6d56afbf58a98eefeb2e9c1ab9a329c7da41a1bb163a9724c66f7c5ae49bdca42c3129fc390d2d203b26bf0f70967930cef551fe612b7c64e4b7f09a7d344199a6521b29a067786f602e0208c94647bdb3eca39e034e17b78968d778580c44ee694ca5017995d7d4c4e7c8431cb5aa3422f3879adc01ab12a15b2396205962075c77b2854b17b273c4faf229321c034d010fdc8d459adbdd1c8dfe06e3aaa0641fd3bbeff1ff7aa23464dd3d35ee4910ea5803d894a58e0e62b1479ce1a29abeefed000b793a1467b233e0b599e1f7526b8134d865190c7a52398d47f32245cf7f315646f5ebd588fa4db106eac11b50b62a3640f6a593e0ab6e0f276e7a85ba7fdca189bcbae5ce5636fb60c38c5b36b0d429c63a811c228eb4b8a5d03444140d7b502c61e8f6d922aa17007142f99e809cd30a2caacfa78c51351137c2fbc9deec56a9e43c534a7788d36469e54c1c45f44809b3647e76f5194536da16ff6f8732ed10b5f4b580253f11abacded3fe17773ff44d855adee4dd7d5553909c3840432c3720fc09348ddb009974f166b633e9c1e44d30434109cc05b20c8c034539af8942bb1948b972a3c760fdfe051252ac7416d980aea30dc2261dae0809e318ca13fbe9c1b8c95667c770de02ee6860de82199d2f04e90a066201c2bd41bbdefdcf2e5f52bbfe1a5e1e345386e4fe491322c52ed38172e1614b6dcdf025df2c629181b148fe001555407b3071d3ff625b36d81fe4cd9b0e8c7cfb100ef0e19f72b064b28f8fe743dcc53a84b401a34a98982daa18161a148f36d3690817e796e258b4801baa69598e85fcd5e8875b78c09e9698ddd4085a20ec0b273ae720955265ba103fe11785863617bc1b1c43dabf41f46d2bde0c15518fe98f80dd7de2ea833f55064dec8839d86d7f1b7bcf14d885c5b8d273c0691ccb6ad86d179d97e907a3aad62599a2da593d014edaa83e40bc44ba467be247041648f3bd1373851bf79ff01e5fe6e4064fed58d0c45b8a5982a76ac5c3c63a1279bd10442bbb5113ffd77f3767e3b4e0835d12de17298a028d0e15e75e22d0031d84bc183e647b9f14e5816d454460b03ac5f2d768a603294830d5ce8773cdc425237fc06fde134336a5ecb668de3e886227bbedb56aeee3f36d8d90f10ee89c8b3b64fe2a0f82073051274965a2cdb83a29e69e733b37df078ffa42b59d5687d212e94d0c009cd78e4308cc5ce96a6a1b535e6e282e81f971f05670466f6f00e46d62ee826933a5fc79079f163a555a3018055f0387134ac306e3132dae7b7037c15ddb0db25dc0d1c29563fbe2374e3cfab847a97eda1d72958c74d59a6462f20fdfecc30311f976883c7126ddffa6aac7f394c7b5dfcf7d6f586aa76312623b8328b20400a59afb8d9267c1e25b36696365bf6844dc3f1b0a0aca12ef6176556d352c31a9711b438ea5df951cdd548d6b4be2734bb5fac5a2b849e04587dbd362c85c3a16b53384887d0e933c3473024e89ec082c85c062beec29e60905eb207e50dc27d032a4e6a0d173f905cad4e741b8e711bb5d88c7ffdc7bd6596b7061be5ff4db905ad23c4a8a816d82d06bf8477a27fbde4233903cd9b709adf0909b810b2b41f7acdac694dc0a5fc5a094f11b9d04ed1409505a7305489bbb2e406e82bc457da8926b3c19f5314822a00e00fc1ddcfdaf2c2e79004e65704021a9fe761b139b82e933c60a93e87c188599634580c22ee7def7eaf02acac7a49d811149fc8b56669800d4dd102758a4a917a28e16cf039c1549062ee80089f0f2be063a4dc717dfb44eb35fe4e0460943c794cda5d91f751bb908558c79cafe74687f72b1f3be4589d1db85e761233b19955d720f719a3406266214c654e1abbf81043f177af2e2eb38b90386785418769e946b2905d12cb45443c6507ff9b887c3fb30f09436a75496fdfc44f6732ca2de4f8870b4184c63f6468788158784039ce3ba8f57f6f825c133cd36d8fccb9c52f5a01420e9e9fb1f465963b84e6115e400c0f8c4b2531a1d8a1dd91db58225751439832b6a453dca30056bac138af658e776bcd7f6a1c2056a26061703690e40fc96f7592577f26b9152e6b5bf9bd9d352e97ba33d08ba4c4925f6459908de8fde487c93f00680cfde6467a2d1cde696f86dad56b3009542ec1c9ff4c1bebd9522253fcf6e1db226c897d06cfc57b1b6f2bdc48015d859fd6248346118d22190916f3a885811ed011257258c857f590d2183769c37be6971dd4e5ccac4825440f57978cc0f8a92ac7e42d26424c70d6b828822ecca663d12fd9adeb62f9ae1119aec577818680a9b4e7a3a2a94bfbcde64244e9568b27faaf83de516b8745b34f7c7ac144edd184f140c4ad28469b248222858bb5b98c9b47fe2b747636ca7db361a8c003bf8ad9a13eb8031eef4f0fece9317713f0f9705bdb335f69008a0b75526c0ccb5176e0a7d98e35d4fcd797223a4ac97f9340aae805b4ee370cd57f0d3b225718ecd7d3dd2081fca78cf25c4fa0318abb1b806636c5ac1af7d3205ffc7f2540cf3b5eac34190793086ed834cb6784dc4f62563e61e3430cc0b1f3c6492ce95f52daa75939f46e3f9fbadf357948b479491c404d8ef3960350625a0a826970576d846b54994fe1fffb56f281a08fdb960fbe9a017d74a3ec5029bc3b69d9c7a421a7ff02d447ccd381055f16dccf22c33a79a4cf686db02787507efd6e3c28c2c4e74aeec85a00cb3c984beb18d0653f0bca6ca72fc4979288dc69e408f02b94081b090689be4369b69571e07adc95047ea25fbf83be3e8037ca1ff2fb6db8012faee855ee63f4f0263f9bd5148030f4d516631da4b41d46fa36d4da992c1d406eb01ea77750f12c7d6b0d76438743170da3d2e179b7584c2cf65f81d658b4ccc5a87bb163cebc3acb07e9ee6eb320219a281d9c85c43e48f6d289b56de16da23cb5196f05015817c2628fdfba9ad00a993699d277b061f49d39f22fe286980cd0e5d70a1baace4e2aefc5d7fe0974c9a5e9fa99bc88717d147263a359564493bf5224dfbce3e337bb7d53521ef5b89c389b4d33456097613ebe8e6fd906f4e18c534672bfbab89691ad01f7d6dce97d3c45e4af38cfa01d30591c601a86174c28818b97c08cf0f161fe6d18e898b8006113edd84dca96608e3a7b3abe1a15b55e3b4e07ef022c7299d2215cdd73b50643b09304b61a46cbdb1901acd97a11e7cbe54d0e61ccc1c4b069973234e0c7b14468566d409dc61d8e38f05ff087ea95ee72f015d5c8fe1b570d14145c77b332e9da7f05b537dcfbe7d5c8fade90b2771f34b8349507b7f0d655b571be237dbba3c4cff59923dfebc677ddb63387d106ff34162b75d82baa2cfd2bbcbfe96622fcebdc02fbdfa08a275420d5a154a49731a6f4b9a7720e2b540d61a150d775b8823d8df60095ff3ff2629f7e0127d104d4008725b51da40a26e59b6d350e74befc11f2b91ddbfa28e7f08e926fe9d00c2f9c107e1369716aa377335d5fc4438b7663bead63ae0e2c808d1885a1eae9c0d6a1f28224fd919497d0c0bd439490be57e4a99b1fee7d6c1957a6ed61017177ea583c2013e69a2bf46e28c5e8c5d12da013d757d44b0ff1dfd08880643f84a6aa84f6ff15fd0ac31d5402b3117e20072f342d264bcb74a9124e35fc58ffcef5e98b682ea242ef4bf015d6ade7035cadc61745fad251493c74a5f185b87a15c310be96b84ac5095865a356bb20af060fd83a390e42da6ae244f0ae383fae9e0e02ff760ec0fdf5b7c6e24993e03ef7c380c917a37caa6c0f3cd5ce33a52892551079bd3b6b5343a80f3924957239b32462899d375d95e1f94b529c5ced07f2ad81e1eea4e912b80347a16b972126b70839dfec73b1f3d8b9fa49444534adbb2397c6d6a5987e9b1b43ce38e8947e410bb3759fb218ea666f7296a865eb1cda8536d23538fc4eda2e408b4b08f6879fba3d9aa06df17493a3d7f7d973190758bf9f994c3284370f2da9b7f509556f09e812160101c5ac297ccb050129378dc014b9581b61ee87ce84b2b9d560dd30e5e6a7fa388d1f027fea01c0bdff87c7b4fb803c59be96a8fdc2ae3ee6a2a27a3c0eb8504ca7d355095491a652b88aedfb425c8d09b3369685f46a1350d2ade49bb5880330245c411c50ae3d79c9a0d08c7a659be2236921bc885677d6fc66df98d75ca7b87809f836bec445f643c8ef4a3d75c8eac307aff66863ef866dd4d904ec1c46c394785213cd6a145820e9e177a5584fc55f3ce8bdb34897bb2c1d525aa27f2db876eca76435198410170bdc65fe5bbf8a23629a810a2a73f835a81d44ea28a91b115decd54caa90d17038d4996c91b5c25fad6f27926cd94c6c672dcdce0e1eb8ce2d07c2846a427028429afd3629f116958de159d1dea6b54555a9a11bdcea2b77b2d6ad9a0df2b290c57f9d2b5cf6dd486f8e6507ff57f6e985dff13aa7e3b1382b0939123382a34fcb8a1ec9e518f5f9bfe5257e092bec14624ded09c27202ffabd355d0d961c05943ecf7741fa5214b1ec18a18fa9056811f859d9923c9eb47c7fb6ad9c90ebf537d561b7a2059f288431ec3b66e0f95e84b6200c8069c6c3c561124d8666741b189832a248b324d80340363c869c2e3e6996e51eae8fbe9bb97472a314cff6d973a164a798595313db25c7ef7ab9bf98959fe282ac77d32fdd648a43faff08fc81a749395765a473c863e97c1d5731edb1f6c5214995c10cda9c8676f830877496693ad2c8ac25b118dd89d0f760a5dcb24e8dcb3eec8262156a9644614cdd6365ea691e5cf2d9b5dd283f6df4078ed876690c539c4a0aa989d92953a06e299971f08ffcacef98897fe0f94ed5cd53bc98b6ab64810797d2a3c1677dca390d524e8ccc2752f897308e36f995862499fcbfca47fea5a81d5ce48a679e8356b1ddc3768878ee729ac8942e65a5096cddca58a289d70465b960a73a3e53629022c6ba47a5e53c3c04490c6e75c039ddb8d3f070abc32646b6b2dafb7a3e53c5f01aaf34e0c1eeb4b5b17bc1a7fa9d700d19c0b1f73a3aa0dd35c53de04a571177b14c7f25a307003a35968d1ce257d2084fd45379e03b7a2c205a8f763aed01f06f93e59608934b0217504e3e8f77dfb5b4d7c36c73b193997ada03ca47e153feccac2401a9361609b2414656a190c06ec6ac646d42a9113c2008a86544fca451b9237634d300c4ef5edb53d7bf5913c9da2e5d3b42eb90eb9946d9c21491a93407a180114193ac38cded3116c04984b76e8fe3f497d979f51bec84582432157a462d0d5b5cc943fd3c424185473d2577b78d97031f8c342d41bff5d656191bf3e33ee31911e991d35e3ef2416b51941be6ab299358b4494b1c9915ee1e6d5c81060ffd10a582588b6c842dc717124c58c4b34b93cd3038ff59d8b017923a4cea645ea03463991692eb8ee803861abb75202f45443ce8fe9a495dcbcf9692535915a86c47d6442ca819f5537cbde5e8d018757d04f4367e43ea6d3562865cd5d2e05799177e1e39882ad469f59a4ec31a532a1e803b37835e8773f515d3a337fe9e51dcb2c1757a21b347884c8835b4525a917bc27134a5c9dd71453b75602f4a2a571dd1d6da5e1bb6c12dcde50edfebab1995a5de99b6e70c46616164c70e52a54f825b9803fea3ab7dd6a132a2147e5df04cb8542d6229cf7d169849ad2781953bd9b4bda6c883b4381197bc9cf4a0b11863737b9a30d830d1f38a6e713ea29519422ded0d61f582c7edd606d249c6ec12678737247b5dea5bc2a7d4ab451109177752124ca57a21db71c6d5c8cceae576a0745714dec7df4f617ce26197e52e5ca6d37cc251b07bfa21984ae1ffcfdf07ba7de67d9e317937bf83c745f47c79d3097ad081362e376e22ee41534f5a1e2d6d6e8406ed792a3f98ebf5702ed522a2d9a315b194e86efd573e089d98cbb87e73912a88b955a2010b12432b779f3cab298b86a7ae981d95095ce97a6501897b2ea8ed8422731c4ae3b49fb383bb8a71ed0cfa97451d477fb676456577e47fe5a4eea24c6d0bef2d9c5f1998d1edaee3c8ffeb871a0517670274560368f1d503ad29b64e42fef18ce75f7447901d5c38bbc8331c5ebe81bf4a2cf5d961aed104cf72f8c113641792329e49654061f5eab0658a05914bb7717495ddfdc4255d9797d33ea5c497c65e5c231e7b8b138286ff01e5433d768b78c5e6a48261f4ed90a84f7621b047090b17aa348d22db791cb59f56532e3478a9f27c4d1ecb9c6bf3d1f1469f515fdf5d828dcc6a6d70f1fa864e9ba03cd5e353e92fc49e8a6abce31d355667074e0a831b33dc0b2586ce5b422d96cf1cb831376cb06ad2ef97cd268e88ac944112f71ddb2051aa6bc8a81cfbd86564d5a63e0aa62f29f7d1d63b4eef42aaffdf4668dfdc54f16a3b3ede1d22d8516cbb7f8bb7b84dad5b15c6dc7ea127fdeda36405a8c80e938dc0c6f78966884ce8a1943825cf4a53b1aafb2c44a24879a680ffba40ae4ab4845fac3bf41394ffabbdc2f680512f3352b0d5c055c0e5107ae9f55212fd9435d772895ac816f774c3ace825aeab3ece7352d8451c2b8fdcc09196a2e36c389315baaed3e2af9b72077e6f10a44352a0ed1e7bcceb5b5a8e1766a12f0fb7b94aab56abd6ff1f474010368387c86fd3d60f0104eb114ea6caee8ab1f32fe567127acf627ca620eed6e2d1c10e1d78a12b8f09d254e6f2863b99aa3d59bcb915b93c14de2642b1c173b5fa6e30a3aa89d1802bf05ced5965e5bd7f18bbd57629b44afbfe69d05988e88e7976d49ce1146bfe259ceaee494aea267aa65139034a3074a6991913b9b55bc466a463f92f2af42e6611c95e15a3f99dd256e8d10617e29f210c8914de9c3570579b5d21a87bd17a8c20b9ddcaae259e0cdbedaf97c6e233fb41b1b9b4e5d4e6ac62859a204e8a5cb53cee51d83daa3eb5b5b6f1b69b4bdbabd7ecded83876ef772ca86ce0e77fda3fe7a71d07b8504ed29b124c13ca9240132977f374c4e4c9d87892b373688563bc5760742600434c714af4b9904e70c5e414ddfbffe1c33a11a93fdd209078b060b4eac7076457eb0aa2a37e763dd774d195a0db9f4dce4b7f625de7910f36f14d645dd1b1e3c8cb145ea886d31b620f8f899090a472c47f4cfaa35c94bde0bfd0e8cf5cff3323f7864a22637bddd72531c0de12344b109ffde258cadda9bc31c93e1c304f3e4a418980d1e238a3bbf594bdb5841248e21057afbff77edbd36b928369eb10a016314776220fbce2c1de7dbb922c8c24642cc948c65f1f0128d1c6fbd72c374d950f05ab307d8cbbf761f3bb39172c3a789a9efd0ef85aa4b48518b4fc0bffcf12816149a042cde4d0e7570f37c6e9420eccafcf8b2aa47b30deafb34fc15ac225caee7f2d189fa7a3afa3ed9370a8cc067603058f8fd02db13a79367e3f7661a63197f02cfb4acf8b5cb8bc7e08583321bf556ed15174a00b7d1e9f3a0004d7baebafaa4e0448140dd4b5dc9620b4ceeb03b520fc4234d797b173c26a076e9e9534eca99d0d205bb797f70a22003c64605be660881cb8140f6454df7e09f440d38e405654cd633f8318bfe879a8dc395284edeeec14a789de2dc946f6ae4aa3a022be6f3755e2675d34eee88982e7005edb700494955da778e1274bd159ef0219136385459fee33acf7775e360c0376b9cd437a12a9586e84ebb20ee3afe690e81fe9519f4b13736447556ffd8e2cd3075b452ff4aa7a2a6fdb2b1a0cd4b146ee7ec60e23e02a7dc1f163ccbbad727643e9d2576809852c15a118ba6573dd655163b3015756806b44e1fcef3580ac13a92509d7c42e0ad4f2bf1027885db309efb64443cada2f284e2cc4e96be1d592a65d0f314df6ee8e15d9ccd3dde2104208164856870ea6398cfb4f58ffa3beb9368db6b7f68b05fc49af60784354c7372ee12e83a610a1d2515e58ee7674b75a2825dcbf8185e390601d9d864e13fa521a01f16efbb34151ae7b68b5f937b3d836027ebac7e4df77f8270d6eea1ba9e8ee4fcd18e40fd74d670ec3736f4621c8d71dc2de77696e7e23757cc2ed92c9f5008c25603da9e5925a3143987251e6d467cb2a0a0aa50f98f76b1f6c32bfd1b9264047c3b71ea48c1158c7fa14af86acc0cc39fd64498796cdfaac3ba09fa81ca9543286347eb088eb38e9ae1a7aa040ceea09d65c8252757cb46576a441558aa93df7b70c1acba73e815cfb2b8514eab59f241a459c0a44e424beea643c9f56ce3d8298eac06ab272076e7ef0433642bc983d416c0d769b0c796cc0bbc5c08118c7521ceb96c99cb25f1df33033f1de93f9a3b27ae371fe200ca0bdd84fafd50aff86bda26181d537d81cf6fb57cc8487bd5f67047bf6f06e486deb1c6f9c8ed4ab832ee7d03490f7963eb896cd0e6b88050a3941ac002ccf4e8e759474737d13228fb852092ee27dfb4a32efee82307b32585aea9c641d0bc38fe004f0cfa076b8d290e623399ce5d79e9fb90448938a8a3a25f9508c7fa32f1f7dbf7d4bfb52b875c2b3c2f3e4ccfd8450e4c2aecd131e452383831b66bd1a00a29025640ca5d798e10b3331600d47b3225bd7212067131dcbdd713c0d3e3805cdbf3c6997dade17646fda63a8fd15753675d6a3235da3340ea8bac36a5350a034b8924811b86aba6b0320ded2845a1e58c04529a92c737cbd2e9432b247dbf4ca20f763a150f6d72e29d392395e77469064f7a68aba427c7bbb518ac6bddf11876c838357c0897509ee9fb395f5fb3bc7a0fa2edf7d7a959bbf19704c9d77330f0ada96966aa3b34638aa7c7c2d55ee12e37e305c3bd2d81d13ccea6f084113038b21f385496f3a5dda19a3e719fcebc02a14ee905a9e4de5ccec9da6cb615077c60b9e1f097ff056017a42d4f3797b6c055e8c99085bc2a555b9bcfda238795d8d8d452bd6ed5e0e977ca7e4cebb46119972ea3b0d62fe1cd297f3168df54753648f84c994aaffdd304d1760cdc7b11776ab8286b533dce6b01368ff12b85e9b12153e51a29e35224199c45c56cd4c246dc64533797fc58c0c22629a3c266c743911f9e36c6920076514409ddb71b5cb213787974627cfa42afd7f6dd198368a122c2ff4f1d54c4e48d7df09710c13a68ab9d4e71662cc32237d370bb69000566892e7672ec494e61d9b856ea38bdf6b0fedbe6622137329014c28b1c24f2c4440d02236996473638b282e15c07e701fe5102d63970c5517f0b05ce3168027fd8ff49f3bfab1474886a7803d0bc384d9e1e26ccf8d26e0d2b5d5a41a79f0fcbc21a77723bb7bc0f4d1d86cf8a10c334cf92a8b864c0877b1501c3161fc8ed88c50f2e4ce72a0057023761b620841df752623a1de38433464d42668e49f6f47b0db17238bd575c15af34283927fbcaf365193cbbd57e215133cb7e4a64c32f1bd367958b7746fd8f1ceb527e81c560bf93b0f6e84b463ccae1a91a69349535c402a0513d8492c04c1b561e4a252f4b41672b0d37e9b2c890a3a5921395a8b7779d3098167e10665ddaa1eddb2970ef916c2e638296732df2d2e9e917a2c879e67f1a7cee999197b1a6bb740a799207bec2aeb81ae2786d566dc9dec550c8249cfc0286384a5512de370799a9daab27013726841a7d9c52d7479ba66675532fc7cf6338a11e757f531a830d5c04ae3ad2be7e6c47d46b542834aa5c555af0909342651e67a744f4d8c59e35869a707538d7befead1636cec9e94953c46e201c1c0cd988ee99d1047a6eadae8caa60d115b40ca43e375ff37ff5f4b678e802a3d90efcb9631b93ccc68b54082ba65ef26af45fbbcb5f65edaad2aceef91d3ebc085b50f09d6f9d23a053c06a67da512df237d6947f145c3b3b305b7251c24a90fcb90e1ad82187b53b746426e4ab82918849925df78255d1fc1a749efd27bc50ef499f34c41f363913d8949b97a79429e2316e60ea8cec77427155077a01a389ab0dd07957b9dc384667e6acaf32cc1b76f8f090790b8e3b72846f6cbb911832f8d2e72cd4b270b794a54aab029ce7ca8f95e27de6e805ceae59fabbe5dbf5307957282db9b713517bf6ee63998ae18877de117c8bea61dd7466d2dbe3665185e29350959e078972965fbf42dff4ffe4ecdf979d8c12df805efacf71b51ee1c8db206d19debe0199eee614f182fd7739f39dcb7a269605853e1506a03bd06b98ab0e0f017ef7925e70d120981c4a36c20a3172f874f631548a3aec1a677adef2d73061c11bbbceb98f18c1d64a15f0fce8951f871edaaf30f8936c4d6c09cfdeb0e1fcc82e501ac103e0f6f8ee47c780d684a420b47b95e321a338a5bb56e7d80dd09a121d76f5e7bdf8d599f4030e460ad62a18a083974e72af62b88147ed71ce61c21f8852b056c50cd1499f4c588e6802489eecd926e0800eee7b24dee486ae95f4c056db1588494c622804e4090f0bbd4bb5c52bc173f9249c717d320ce4422eb887303eae3ba7b38dedd1c31a62fc48efef95285bfa16e055dbdc8c2623d63fa7a4c8d2e48a899d14558755157eec319f9fbd98e267e7d7e8e490c884629ddf80228ff0ea02a222a8644d48183c6f410fcbd804b9a0f654c5b7b8af8a009ae1b16d0b1e3dc3fa1e778ca3e60abc19934a7f17aeecf2b65dcf753fadec3b6cefc6e06c50222f1d5e129f92d1f3c0b3c858dc8e5ac097e226a2ffa4fca3174696d7f6c36df3cdc68dfa6f40e4a360f8cf8eb45bdc500d33439e622278e5d13496e32e23e41d4613dd5525aeb15d1f5493072adb30e15e5115c31b573b0699d5ee7402c4e48fd3669c3b6484c2c22212f4cb7c8b456122c0e652598d67bba10519f0a019df3d9bd83cfef1d0502e64f2fe575736dc6e863175ca671e260026ecaede60e02a6761273c52c21cf8725ecaef8183989589b8434e441535db983d5001f1375a3ca523276fe27bc0f344bc16cfc74ba29f601ee765e0679593c4bb135b75431b9b325773dc6577b0a5d5e6cc7e348f4cd77757cb1765c09efa83b904dd20c7312dcd67905911705fe01832c1b31f7bc47eb411cf1836c2af9a8868c00703e905e645a53b589de1269df506b6c1d63b787e5ee6f53226770cb8dfbfd340a4a410d81c2f9e40ab3cac62da437f0401c8c77a8efef27557ccdc1a90ddef235ef1db1f4c3e92e6f516cb45326fb5f6c7f2a224c14f92224cefcbf60a681891b5296bffeb722c31eef8885b59e40f948d568808f2c92a27ef6633300b7b9eed5d92bacd140aa158abd707c0a934a8eb1470275755acc0047610d09b8dda9fb740d6eb13661cba00152e5bad71590ef5c957d16c79ae5d40df2c9cce8f70849b8b42ec1491b1c8c2cfbcf833b724a46cec688162a15a7fbb9edf92aa443ecbb11e287d116e4c386299756edfbb9c4b14cf99fab9577d88457e4e4c4418b771c31b18aaf7aec3f01624101edee1111b08a34683f90b889f936c77991a55a03854f2e986c6d025d469cab929b9b601c5529c57b591d8963003451ab33bf56fc11ba3391a8ae16e2f8a161b4645b653c75db37fac6e38deae059ba49b9f381819f541448f0bf8965115eddfad787be4e7eebcd73f99944ab7765d7cc5457485815872cdbbcae8b6ffabac7eb5cd02af7a17917dc50d04da6ff609ec2d0cc02f437587186f67e701f27adf9a79255253070143368e2b7984eca46fc51f90a570674f08e0bc2cb2419108d13e8c69bc5f524f656aaea9042b29cf383aaa64cfd749e4210a529c7bc89a9699b77a2d87f4820fa47f175aef819f8a84411b86e206716be340de43715293ab1328e53cef0a1a5555114299deebc44df379f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a459eca06d075b0471bc49735ad3e7c9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
