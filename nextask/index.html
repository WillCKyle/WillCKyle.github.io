<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #E8D8FF;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #000;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #E8D8FF;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F2EAFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Enter" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6deb06c1bba072ecce15289f96cbde0aebf056972015bb6694cf67f1f6f7801c7fa6da3024ff8176755ecd284add9b47b1903837d41b25aa46209a5107846c6d7aa7fe9c54adc6345231017e55d67a06b6065160d309166a9babb5afdc60dcb3667bcd18f3ef4c9bf76486acd2dba989eb7ca7c6b8fd91b9b06d235da6b0152c1cd833152fb65086c61763bbbbf10d72248ce2f6931d4db7f6ccad48c59ea3f127a95d9bec99b970e581003244465b40997121ecb47d0abef2757f4c0a7fddff1bd0bc0f987de4ab47182de6244eee94136825a541b0f60bdd170e163f45a12b55754158735d48eefec1d9f25c276a7de0d261ec889a9e079db4c0da68f01cd27cc57e1ac282975bc3635f20ac158c4505c3127d878f981da8f7e4491d9167ab19a9af4bfd13b068c19a3ba654cff11b6a6d5908061edc02f66e2988af96c9c6ff8cddeef68632f5fc02bce095487add24875f78b6acb8dec6c66cb450a1bedb34a1fd901dcd7f840cae80a80f64efabbd0a3e858bc501174726ee48271e6ffd29ff0962dcb7b9c4a443a926135b527dfe6d6ec33cbbb94046aefbb92f0f64e1b1c319edaac39626dcb6509c7d8fb4d1ef452ec752c4d1d30b9102c549ba958fc43c11007b3dac52770c7e6afadeaa74956b03f683826f41cc14d6af16c176fe7fa1e59126aaa02f6b75507705268da5703b28d1e7c40c679a64faab59e5a0846de85ac81dee877c28c217c38be6b460c088090856bb4f3e6b0de3d69b58b555cc293e871077aa79df4d8a0b6142daf5170436dd0d6b072a3b34c63f1ec54c286e11db2aa8d2ae8eef87db027e044d0815f93b7b4a5e5a5f506068587c5854885f8ff33717be8714135ec1ba13b2586cf1d9a35199329a42f357b4abd69d0e6537f5fa1bc3a15e69b7b4e4c5ac15e24c2d064638bd801c3b4d40999c5d9a299c5c4aa701fa527141e19ecc598f14cb83e6a6230ff2590d1fb059e30ae8c12b87a1f8c9d14f177465a5667fbbdd82b7195d62b7cce7882d5dc39efa68c89928789a1793ebfc62d577223da5fd2dcecda6395aa3c0bd60ed998aa9a83ef9123032fd4120c270e427c811c1dd104e4ca301845b99d2c7264b2edf5a814623aae12b4821db58182967c5e32c14ee6e0de091e344001cf9b8abe7352d0c414a291eabd1ff7db31ad04e3f5e4fffa37a59a8e9cc16ec9b01cba0f7e06896ffb005f14d7236d9eadefb224efd60772c4efa3c6d2f1ae5b79e780afa0b48598c308ad42b119f7eb835dacfc775680b3a2f99282677f20f273e51419e553e104d2ac3a697e02ff93a9b259f749540773f7919f8ade2da26bb3b5bb056d583a4af1d99f5687f143e363a4ad09d2c7a4389cfc1ad1c3dca17b2a8b1a8cab280048c5f39e2466cd601c8dece6561d95db0e4ae7b46608c84e18026cdcd8b7eb44e57c24d35ecf103d9029b1c16f26c8752bef03d40efaa6f3d353dd07f344d1ae6d55dbc5b69b7e24020833f94ae807d986de9b30c6b2da6fabc1d65e8ab059f4cde43caa71a44c44569cf430a20ab85ba1f3a3041e1ed80d447e94477cd354837983e827f48af66545c7be2e41af9caf68b7b1d46eba84223d90e4dad7bf5abdafc183494f0d136f6e97f309012cbed8f0cb2c49eee5e5abe10ec6c661b5901d66e7b2c818556d9735a404589c166f88edc78a8984ccf83af51ce202b7015db4cbe87e46c9161c1752652402704fd4d48c85d4bfc8ba07332a3212c9ddefb633c5e422ecaa24e634997a221d524d0de67b9a9807cc50937c0c0deae358ee69160dc21cab084f4ea4ae8a7bb9dc985b4b7430a44e2201759dd27d455ed2e2fe899ccb03d7cedbd21b0a35949f14d7979709a0472cbf330d79a67e30d7ca04c902240f42a413531808169718939b9c0c3c2b73d0b210f018932916c0cfc8602680b7109d58f25eb3af2a4bdc590d48fd74ff0731d2ac73b171ed42372297ea172fa1c60d9ace820a7742a6d720d413dfaa15c3c0ecd87f3896b27c25cdd632b6776196eef45a48727479767234297267fbc4367c2c6fbdaab4673013737fc0e83fd3216da96d403be3a5d63c34b8ab3a027a1335b414006ad77a838577e48b37cd87f887c73a15e0e2dd2525dc6c48999bc03dae74e70912aa9dad1952c0dfb54a49a9e1c7496f649906e048bae6b738be6ce788fca5decbf55b2068e203fa89922f47be5237bf6b5585bb4769771dd82436cf6db367bd692712df7e296d1cfddf151647125537bc9e773dae5b6f23fb432bdd400ed02073f63ae0354f35160e44527af6430804129ec5023182b0732d3d98cca0755cb8b669a71b5ef7b6e094ffd4fc6dc9e67ace8048b3fa61e38bea998a6d520a4de58ce30c3c56284f814ecc7baae52364f2dbdcdc39ed7fedce3d91587f51eb0a3f48e92f18b87bffa16932f7c4002035b55658bda54c7b7a426ba5bb3c1911281777f41483ab834234218f2273bc362af56152671e1362817be1efe5819f86c8b6466f18eb5d89ebe116a622e2c37824cc124277e1cb87127608a392e37df5b24e487a0b0402322bb5fd2907b71778b4bfc613a7a4d92064238e0e7ac0303808e5db9b772477eaadebc8ef3054f54e58a88259d5bcb7a7d228ec19acddc77f1ecee5236a9846f468af494db37ea33165c085d4158edfeae325f030e7215a6bcf12a39f5f91f5db8c343c0e98565bfd9989263822d8ec19f1b7b76314368d36aad90d4825437ce4f65ced2a4787a69298fccacd4c9dd5405d16ad6a7b06ea2e72215e54abfb770dd71508ff57906b04ffe52d9f9edf3128651f1c08dae93f56b23a50c0ee56218cfe040e9ca6911ac26864d4b911c0de03fdccf522398b7be8888ec467d5fcc1e1d2c3b3cfbe5c9409184e4d65fac9cf2b34864e5b8c32ec6a9e3d607b8bc8cf7467c83b02516a30f6dae34f7cc6fbb943bd05789db744ea9eeae7f417051329e254623eb9ab48fc3e6d1ba4277aa976faa8707fcea402f2e4eb06a9fdeceaa616714b34b28842c3e532383b6ebd6ddc7bb1c655cee8960ddfcb82c6ecb7be288308db52ca0bd43f56bacd4dd37d7d6fb1bef5f747da7ca29bcc56c4b1d40b97e5e881537b7a6504726b6e2e3a7071c88d33263a34ca5643f44876bb0349b73b605f084a43d9c3134f993de0ae61218bc000001c7a8970b0e2f24e536069981c7e004e94e7c9f81b269e39e8b0c58bc9f45c719669d0d4fc9cafaa3c07e12d4a63365f764e5a24809ec29a59329444f7d7359fd4c4771f679823df9c526f9f44f0abac9b5a469535af28bc1b0d2e06aa902ee0ed94b1e0d98d2801fe6f82976140a5f92c66e3d4eea2cfd5184eae6843d57c263bdff1c0ec8a843a2c8fddf7124a01ba0e0380af193c3b20798a43639af0691a3c5cf04cbe206bc0e7078eec03710367a99dec3653efbfa0d7855b1ee7e722008037c3e00fe1d77eb65166282bba05e6df49e573eb0be3e445908e03ecd58e60b769c92f2675a04d4c9764a8f3657aee86f5818e2e05c0befc828fbd27087c4a17b830cd34adc1b2ddf312c90561b0f1822face0dd9c39ed646370bb06d215039723edf902e20059789fa0f3f89b900ff8fb4cd86cdafe5a8435dbeaa6231602969bbcdc3fdc92a83439c21da265952bbf0c905e869b60d48064840c9f133649195e46418b681580218343eb77b48415026592ec53bc188c65b9c1e30e386d51e44fdcc09734b3ed3be16a22369fa96a020d98f8cef8b61dde41faa66f7e681c70fd817024de5fc9a1abf5f18593ae490b4fdb5c0f267777ff09165654845657b9604dce068696f65083815668abf81bb29d5a3c37614d41d8f00a93fba7645fe633fe2ab477cadd84fae783f82e2737dafeebfe6f9854f3d7c03c863a50afead4faef51960b1f4c817496d228595493150eb39b23e15e8685c06e0744cd7381c34e860c806d9dc7986a1ef78e2af570e6e8395d549dfa502f68bce411c7c107c2b298929e0367afb63ad1b35728806d149dc094457b2e03a030e56fd091e298a1514dda9ee955399462febf1fb17adafe52685bcb2ce83c705b7075e3c8d3cd25f1a5dbd669c3ffc399ef99336ebc93451eb6011b8116aadee21ee42822b9dc4a5b9b6fbdffe5c0278de63be5f6cb41a7a74f7c24d5d6e2bb1cab459b8bd4986f268116c269e5a634897da89e9842c211a6d1257216443d58b042d06b40e4f026aae80ea21b51359c996bc26c26e3cf3226dff207a6a6ebf9a060afaf588e7ea620a71c8386fe1bfa8d5a21254e209d6bf1f22161fca9d965710790706024a7746f99461a8ba09a63260b1086b0ec829a936caeebc0901c45c5958366fa4235cd55f8343fefc2d7ca8d9ec833293ac12ce3da757d147f69d42cb812bfb03bd8707760f648245c6d30426f6074eaa4c4a0a566b7dc506a4c422de068da5eec09d1c05a47424993e62085fca39fdcd109470899cfc26ce8186e5265fa43cbf02a29ca13c52d08767e3cf70345b48421f76ef522f01fd4a53699d2f14cbc5a3b2195d9554ef2414de27a654d71845a8b64eb6b6df5e7e74cace7d0bb02197383f53c2d2402c926f3ad51a19344c07b9875c9f561cb3410d507ceca6f643e3b26dc2f57e1621c0947d84c3d026101b292eafb9ed9d737a31d237c13bc8d141e532480ec53122408641015d2ad36b58f78ead24d3c7edda3346b98117385d84f50987fd068677e0b8365ee89e43573e729bcef224a4036647b9cb9143925b25030e467c6c9ed8638653569689cf2f5556b9d565f7aa0b9668ddf901500d959e028d004773791c1a954f87e8bdc364e81b1002f42f3e3b03914bdabb7cc2fd254d1d7d7bf19221fa21059928d7660a1c128ad0caa9925d52142fef455f4483dbf6d2ee8cb0bd9343c96df39b673bcdcbdad5757ad944b53f840bc03d5996e8325568a7613aece5b7ec99d53a93abb32317a181971b49acd82e102033376afd5b16c27018fe925ac012775418038c7c52a0d21605d42c8b02571e21f7861979ace7d87a02294f8e7d7dfd8e97848c7518454eb65ec26ca0b9f0e181e057b540533b7390125a7327f8f87e578fb718c260d509797927655caf72d537900fd7b59a51f596debd060f9c57ff72b30091ad652a004582ebd892e48714a03060f7fe225ed9b5559adeac2f316309b7919466dcdf295f470f79dae3eb40636b0a27fc5b04537ef4f75149db17557b919c1151c65f6773ea13845a0df5303e64a24ac67fedcc36a7c66ad80e7795a394c5f8ada77f1da631e57fd86598b683e46b36fcf6652c51a051075f7275ad886ec8c44315adea0bd1f4e18c619996ea61b2c884fcc606086d24527155d8a683796bb88cb2adf8c5cd2a610f3ed695634ba3e52476f3491ad655efc6cbb0ac9ee9ae0e1b3d9f5dd079a5354fd4d62c21163cc7de9fbda190efbcb330233e4b7e071df5dace357a271e561d36c0d62932f571fc0db89108fa302f4b515813ce21938a3c803388d8a105a88525c1a18396a921cd38b6b30dbd0e3083b1b8657560f6b5e649301f2dab2e92787ca2199e96d6f2fd91c2ba7b42aa6919dccf9da468ae3b39367d466172905cefcc68f72b65828a2856ccdc529daae219a299b47fb7b9076d132ab64fef2e49736400886e2064944047df45ee0e41b97fe6e89bff840c52dc072286e4c99bc828d54f2370a25373810c154d881998ca0257f9a06ff89585c5ac007203c140ab97c378976f98b46ab12cd65c337fbc1ce38583726820bc8292d8bc1abea279816b38822cd9b8596b4009be067489177e306201ba41119a209c495a475c6d2216776df26c7391dc00c6c873980ba80f2167ac12a7a13d5cf0cde57409dc512eb0e5ded35e347a776d57c8c1b95a480e155038b5195939fd4daec97b3881f3de5147dd7612449091dfcb7ba1d345824416c4b994bb469bd50b68cc0570b8db03477bac7579eff7f5d7be176506ad90631235022ba3d2cc37f39de9cd3a0e785f4af3a554d48bc6b65c0b88435358b8c8476db1048a95a7a04e8e8b58f6e45bdd95601d4e6f4c43a89864c1a48a968e50de18759f5e7f22379368a410709d20a0ff4954e1fab2d57817c0df8e21cdbc4258875d209b3b9de0536f8c312336cf51a40bbc35f265d3280a2bd8b88bd0d0e3014ed747836278c96cf7d4b09ee6ef3e047ddace0bc319d470d8b37efe3a64fcd33dc318bdf1ef14bcbd54b98bbcbf3c72fd521b4d2a717b7b825bdf20b5f4a990fd6dd78e28367a71a836e3cdef20b06ad7b1e1cb2bfe18a9245573f2677e54532518b1cf484acbada1b07340c1a1e56ef86c45b1666413a187c1d4ef3c8ecf1a5ef8b6dfd371cce1c818ad437e155cd5b676d92b9447e0a8345388cff7b334c110175d7114a8d192c96e3733513671fad398806f0b9b8a6a3af29cc9c3cdc2a9263dddda1eee9417d8cfec75d2192e1549085c11d0298ec2767e766c9f7b681dfcfae28cf8b5c647d1208c1b52904b7101a6f33cb133eb3634936300851b17572c430ab999235a3296c1015f6c2236a9f43b63ea5cb53c985e70a6297d3c36af3d0f527120f57f4dc04e8b2dee6f2b745a47d7bb5c0349deed08585f81c529560551f7a9e913ce2d05414b307735cf940ca9d3d3aa012b0a940624315fbbd8598a734efa9bbc22c724a592c13585ee3fc42687235a7e85ac2d3316a010242877534a82d3c0407acea0d6792a0ac95f196185b0843c3fe42c69e6d2d14764caa62aa6d2402d414f7fde2ede132f5c6cd7e0b4d6f32f3b97d34b1fa8861b495800cd85a8643407de1c929c3a423254b309eeb7bdbf3d06bd5c616540a64e504233469e082e78bae93aacbccd4feffe106b2cd2944508dc4b9dc316312843138a9350d3a00c833191e72bfa049df0fe9e3eef804d5c50032f23f3b6f6eba47721d0a72ace608ec12a1d19ee29df1cbdc30bbb87c29f47d354aaaa9d636fae2f4f2cc185a4009ba3813a0b25b6dc88d2a7241ad968385c6168b6cb764f870356b1735d00a32e48f871f0b7832cf9fedf44e0f2761441eecd0010e3658026d3f5b5979b22385d1c7d3e80a85f69e318809e992f2b0b71ed4520357a0c3de0b8176768c9f128e99b879ffedc4e6ea068094780094cef7891c3546b981a6475bc516c123ae46d5bb84a03e45bbdbc62f49d833dc5901677f1728482359b34b3dcc77a1ffec00c4b644b687d789623d6e977cbf06e2ddf0476219feb1ebc918bafc5dea58d21d6d8bba59c41cae9c8d48f69b0fe205bf01885b4085de0e5c23a18c4186a28bd9dea0cc9ec0356681b6a74c87fc3e9f1c747193818c1677f50fd3fa74eee068aadce867443a165cd8f1171a7d304e81749957dc1039c32d4c4d9eea63bce6950923d373f3e18d4bfc8ff260424c4ae3a860b7f02786ab6595bfe2969faa6ac4450144c183202ee606fe73bf23491a875bb6fe2c11c12edb140445480adfec7a5238a7b3d540ab868c66cec04488bf8b713123d118491b6bc5765762b71d06935378cfd72a4498f73054a03964f6056fbe55c6545c9a9e5b0e88344dd398a6a7a063cb6de4689aba8e086a259c0c723e222d7fa0e9cdb37fd0000d488eaedec69612efdfe6a152ebc59f351803e30e0a5ea681acbade8b0c1a4ce4987054da01508486f632deb4f4f2c26ea37771424db8aad8d2ca15ece251f01de140570437b20a00215a7f3d3eae987c0b969bb6c646fcbfa1a593cfb483f25b036f55a6a4d515dae40eb0047250bed776d63e7af4d4c024aeb0736ff9387e39deebdb9b0778e9f6b91e570ba97d7c371bf95a4b2458c14089ba0d75eb1458defc848dc79b0a97277e8e1f41acf87849e1f2c31343726666a3e770b3c130307381390b9310fbb482ae725350fc8b23a11e3afca94776a96b33eaa16d69c44c1b4bb60eac1edc8c0270e8f4a71bb883b11d646d0d29c1f6df1df665ccc2a586bc54c7f4b7326dfe37b1345b9517cec3f095d01a01ce2b2bfa705ff528d10742b69e87a367b7ef1a12b88e398e7668999354380008c23d4f0d34845555af21fb9fd87a0169003a2e685e33aa481df8ad40cf4f015aa1c0b8ae76f639a8df8d7f55516996f947dad3dd5a671dfd495d9c32ca226e80881591d8116136ec17ed37b8b891499319890b9fca1f6539998aaf2fe26ca9dfb160cb348f40aeda9ad58971d1a151bfa6c65f601a5e1cc3d4f4ea2673863efedcce5327e7555be98be118e120bfa72483da65dbd449cbf227c42db63df60a7d1286a778e5ad552cf18a7a697faa8f2e5a3e1b5d7a0bc3743e99098fbbba5dd733e9887ac9353b26957652d70d665f4363be462434cb220163f1132c3683c763b3cf9fe69745679a8d1a89994e0d87ff1d44c496104860c094f62fccc40e293c5cfd3aff7a5ebb7b89839b77403c6d07d3e43a09f58b7f54dbdeb77976b28e0eadd0d96c25b94e08ea713a4df008cff9786654009860e3127c062cb7c0dfbefe1fad968bdfa7b6f4d05d8c6751758afbb7dd60814bee134fba76a6847908e2e8ecbee703c96877796855c33f309c88ca06c1ea8e5df35c3009f3c89594ca0b69b95bb9e7bfc02287841a0f37665b171253912bb48cfec5ef3dc175fd9188906fb1cfc78bd4fdcc1c01217ef716e8758ae38d58a2e4657650522e0cdc8e57466af21399ecda639a56a187781a99cebabad2f7046d4802617f951ddc3d826ecd794593786906254dfc91d463bc7068b568a011ec462d6c24bac61930e621bca0e6916c5b10ff84b3baaac9cd1049ef71a80b1dbe2ff14bc8e177981132b68647025fc03c9431be3d2d9510d8e53a8567a93ca3a22e1b53b73934094ef467121d4eb4f42e00fe8020305e51963dfc2d5b89fd856a82d5a2037f654d78fc2d57a49abb324906a23aa11d0531aa257eec14e163085ffd26c6264bb63a4eb2faf7fb19c342bb11786e5a3672e9dfaf3ce0b954fee138fcb73b009ebc304e7f6340d719ab753f37c6e123bf841de20bfe9d956ef310f95ede340cac6d8cfd3ffbd81ab72f2828f1e265cd84bdf3b5e51088ccc755414275a6227043fb15b2eeb3a881fb3ed86f49eed5a8e92993fb1258d0522a68fb89ba0c8592d69970a627423130d22d52467e3901c175f921f8d675c350c7d0512818ffad8879673abcbbc90868df58553e1195c88c217ec9ff5e9b842e0cedbe769eccfb3d20e0f35965cc0291a856ece513a136edc07b9eafa35dd23ee2bf63274036355633aa6da2ce995b0f5503c30e3eb591bef2b7c69b8a5331868b51c5b2d6a9e6c4232914dc3506cd414815fa8dd2de50302a5c181b0d78f03c03508a41aa626395d03888964098a886e1dbbcc7df0ec1c0505c4880c78959106380033d8cbf710a5d3ce7edc5df0fe8cab182961b6818a967d20bae372bce23bab4c8d7c4df40a77c6c0fd3c73cb38b629013c7ff8b8e7f58ce941e19648141a81c45c7efa8b28b37295b3b1bc0135f7e010b5a0ec6058d3c82208fc72734f624a5f862674dece3af79f9fb58e657170c03734736e17bce1982dbfe377e94364f98cda63865f37bccd365ad7a0399bac1a9be27130c4ecd5e606b8cd852e79bd03deec632d063d3030112337f51dd30a9f6dd241bb427d617e2627aca26a3047b810dc45afe719ec1bbabc6023b503b0785c887478aff8c71ecce5559df20e61caef1a46d5c9a64c580db579c6e3cf530445e794bc3a829baefb57d0221d4aaecfb0b1bef52ff710a74af3ecd691672494f795af2caccb5e6533eabe00f76d289918c97c722163005d725e5d09c0c4a0acce3da0119a163f1b4b5b709d50fb1f3214c479be0d89d7890457fcdb1adb37e081f380fd04b765bc5f063720cbf452bb66fd561d58f11bff2a69e0590493cabe01a2aba1e5927d3e593f31a882f0ce2ee6cf2123709209166c7e46831de0d82b72f6810dab100580a73b6a5edf0b8f4d5676c07993c687f2c1341f048d1d424b3f8925ca496506c875344152d4486513ec1d13f621c962e9d88f833bfcb31764c6c07e1e45b36d71cd8af09bd8418ea1ca6da0107a6945a95b1b083c58f7b56fbed82afe7a66a383ca94708ab29dcafe837760481dd9ff9c6249997c2d56300053fe739f36e76eff856e0ff8b0334afd0a4601c4545e37b4a6658686a6fcfab003ad7b6a3dc2bd59b10f88573bfcbc6c191ad01fec32e3fe67b48c54068398d3abbb08468e02e1f39b2292fb4c15a95873f3a95e8e8aca4121d52b9b3605ff904acbf2d402d5590b2cfaf1239eb10b6aee02893050cea48189876c45a3d9871ec1e0ed8ca96dcd15abb3a315c8db34d564cf13764e50f96c1be0ac8f8e115295f8d7c873e8516d3787e46701f4e3b122d2294ab45fd587d99b33d187b19b4d823143a136c05108e7f40bba66a4ab3f1e05ccc50122d20e824940872d069f7e443fdfc59b58beec3e8ad3b83ef24e45e28f9ad7852ed0224f12e83c2e24b98c4d2e22732d2e0505d0d0b143ea33ea1f2bfbcad4f38596ee75380d22867229e8b547db89313faf52d61e2a80d238dc2c1f024270ffee3d9a433ef8c1b915d4c1aac32e6922ccb7a118a27145994f6076549c95148de2138906fb0c8bc6aaec10f7b65f3391d603177b4be479dd49851300fb2ca7824d927d4d3996f30bd2a788d56bdb52a1de00c0b30775a24dd8e9aea8427d739f534ab53f1e097ee1d00af7a5d99896698df146909b3181b4823ee9c0d5ec3198c10cc352d5f2cbb05b1344062975ec5391749023abf9049256f8ab5f594574d50d94a5885c9b4c772aabdb4104abf02fd7fb7ef6d2984bc00a3038b65b270c1bb778014e4b4d0d820cc7d57d1d0d9cab452349926005cd835736a91380e4c75b0e274b77697240c65fac40713e70763971cba948d408b21af895068746f8a0b84a3283f8f3d0c4147830cb1d5145a76fd656532034c14d8447db6fbf50f5278385b427d3dee7de2cb590bd48883511c87ef0ad9ace74e6cf26c62b188cbb23552a625a171e4c2eb6d8581fe7cba8dc51a6bdb9fb4beacbb81740d0b560ac53b0f2252363535d7bdbf7adbd573858665a5958c660dcdeec83b9f6e58d3758bee2543b39a619acaaaceb696bd2cfcba0661ab48815728834e9e75aec03e47564b8616659bcf6fdd0d7733cb14b9de85937aba0813333b476ac17ef1ab70389878eb2eba4c005b7b6381456a6ed6ec30ee5bcb733ae016bfa84f8330a0b537d5dae9404253171d1105290f9afd5204b529288213ab02abafbe6c694d0c5cb14ed136653da366989c92d3738371f3688376f1a5d3daed2230a8752489ceabf8d533d4ffcd1f1f2b9c1717af97b003acca70d3c163e9b4b2a6c0f996dce82da8d996a56dad53d5ff00f706274e4942597138044353df68373632fa5b4e513406f8a227866c21e19e4fb5684e17f518792000d4bd4db67ddfcc913222787474caae69c0a6404e5b4b94e52eecfd1805c91a50b47915fa457e1b3013386f2723b96c84e636b418f662808f389c86de7bca585ea56573fc9a82d9f8bb11caaf2174cf743b85363ab612f4d8470efd0028b9af829435e51063208cb3a63fef3501d2f1bfa10c1436e1c7ef26ba15e1648458779976380451786a87353981887ef71580a8638af43627030caeda56008ef764e02d33edbd1d86a8245b0d47d512abbc115f046a739a974d4e5b27ac23f3e19a420fe1fed08228308a30ce985014f2425c3414fed2d3377e6bbff237e84251877d20293c714456475653b7f9dcd98c0c421af131df74801c849c05d36b879501f76dbd93f3bb37d66049bd9a52ff423ae461dc4edf616e33e5d9794f1403eb4b4ac65e4e59d735b791859342be4c481d715f5ae6d008cae5080f989fae86066c19841eadb97596e8e728f4978859574e80b0df423d4263253bf2849a77505b5b55e165299b2f3d5f3ec3826d48d0b9b56a34aec6b0d06c247a4ac0a5f4c0cfdd14e8e235579d5228769cc792c4b730f205e64ce67393a15d273a209ba920952cb77dda5e673bec1b7fddaeeef337411c1233d04ec2769c1ae014a968cb005f6f4684ca7912df77a57dabd1254ca162bbdbb908dfd1a5a37f252f38998bd15ff6cca92688c7b69ab68be3d8c923d53bcb35df506a1bda5576abe25075a265fec406f929a2f10b1b0f400cf78d846af0f683e023090e29920f7115e631f28118acc1b85a3e64950f3c3dd04ba31cb4f90c89289ead632622314cdae17a331e76ef00566a4ac589ba92217a6397ee335966dac63ab648f7c535fa65e81015c64d89898492ecb956b250a0e2f6f5a22e65896817bf8328426c763dc64fdd5bfe21d35733c597a950825fc5b2484f719f428694195ebaa7b8bbb81d12426ea703613e158c6312ec574422c5b492c1f3baff7d397d3874feaa28850e360e1d6de0867b856e1c8952eb03cfa78dd1f956c5b089f9eef25a46647784809449b0794b77a94bc5ca9f2318e7b2ac1429d73c2337c5e60b130d51191ff16c1a60ff6411196f2faf0ee4ecb83009f64b109ebe0c26a0452c462792cb707f7201283fa637a8ebe28f2230dabc5d6636fbaabfbd3e77327895ebf745dec6e9c88848ce03d5d12683095afe1c216df83a67bebe07b25040556b5d78ad3fca623678e5da46083c7a3ffd57c8dd903bea59c62c789863fdd4f1676b00c9122af326ea5c578e51e640df67042271d4bcd5e19fe3eda46aa78f538d4e51703721e795f94ba872f9acba0ec660d93884f3c4266056486c490ce886260ebf930f8b25e90e3ba8944145fc5cd71e7235af2ec5f3c2e759ec7b64aaabd3d279d4caec4d07885bb5b1c71257e2de0a945e6fa099190e9c44523e3f6890e6c7e0acd19905336fc1325c51d7aea78d5f8f52751fe7417cb81c809f91dcad997e8f5a341da7eba2c598e8b68c6e67930a47f3e3bdc742a90eca2f202536fff5b8f42d2655e4eddaf22ee71032f7060e308f518b227d5be402f541eb44b9dfd60d5e94c00cbe9b49b0ebfe000c1a4314f6fd9c6e02db16e302c1ff3ae3946ec9b55b22651158da51f4bf80119a0440adc1c4dcfe0ede6487aa7272d39b3bfbd46da047154f774fd70e023cfd201ba3b99ffb657103015a24d65749c4dbd934322b35eada0da47eb99bf38e0545a51071eba0a87cb34d09213d6a15b11ca51816a0d681395be8cc7784496bef3dd92a311f7124f82e069550642235fb37adcc24989a4213263e9d638999473e7ec4b6d2428503e6e5ccb6ee6b3684f0452020ae7f53c6116f7eb28a8b8a1eb20bf4561957387f00d5a03933e548f89363698a22130822f871c18da669f9d8d90f17def07ab727f70135d53a71b98a5dbd46ae8b223998198e135afb4fe8e5dfcf723422f7af0769491ec9314b95ede7e3c4a855846218479ab1f4a5e4dc4cafcd28f225fb80cafca33d3657afea535d4d3ccae5c558b3ef60879a62e2cd945b225d9b4fa2614eb0812751f9a39ae3d438fba8371e51a3304d27183f6c211cbc9866df3c9931b8eb34d0c2081f26fc4fcb7b52bb9b9cfc541c9c7a017259ae0107c128613456eeb9ad76afe516a219c8a966e4cf8df7398ead4153f557f9aab6d80ca790f03f5230d67f034d485e356173d9e54daef8d671f42af0c4e6c104a6fdf0e5e9ad8f3763ab3bc7ad0dcfc1c4b0a2ad9398d31767fee5c696800d60e4e8127296f5ce9757caefe12a69a61e2b6a1974f8013f8b3040caf3c85b694372b63a557f44e34dd497104a2b4c28c5b48383646b5d3a9dd0af896614ced703550f4c4f21c7eadf2da4f2106c2c9014ada74c04d25b008e5bb967ca85183c2dc3c60b431e8f18283456402129910f95a5f37e148aa8abd4a54f0b302c365cff8231916398ca40ec7ae82d359c95faaba3920f280631984a9d9fbf67a4c3157a1c63ccdb448b11fa8ef17a788f96a4aa8bbdf9e86bf65aa0b9bda6e1d846149742bbd767c57d71d19087d4bf189cfcb59b25239025fbf75795e14a14adb03a1b3a398de9329e5915f6e6d880fc47080aa20f1ea5b81b1c434f7e3319dda0b9eacf51496c5114c07342f122fc740b657eeb5b2130517ff8acb6b664ff2ad1bcd18d62284ca2101aef644cd785f3f1f40efcee8a3e1cd16605db5e73eccfed311b360a4be32585f25463e5e8c388a392c87b8940ab9d164ff9ea867503d160c9a146a13a267472396bd9df312ab63ddcb223e9fcead1116e33b50a3264161e638d64b88dad68fdb1ddbcd6599c356fd654fba2a8de5b2276a08aa3d74c09295713933e330799947ad36e7d43f3a749d8f3012b21527334aa39534894bb37e8e91ab706e731b51581159bc881dc2525d1fabc6d2fec315","isRememberEnabled":true,"rememberDurationInDays":"30","staticryptSaltUniqueVariableName":"1cfbff9a20466d4423f7a93bfac87d4e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
