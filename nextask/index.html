<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                
                outline: 0;
                background: #E8D8FF;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #000;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #E8D8FF;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #E8D8FF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p><p>The password is in my resume.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="View Case Study" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4402eed3f95215f8fcce7fcfc5fdb7acfebd1ca52e616b629a4f05b0e1c7b11140c02fe9a0717b14385098dcd200b570048de90a052eedf83ccb1f68184f66853b627b35bf0dcdf09ac7d095215ce12791b1ce03944d6ac6ccd62723d59f5bbe001d8958f095cff9e308b3e0e1ae7d1ec57ba7849ae2c42bb079a1bf12a53a58a81b2daf70d4f4929f2ff43c11f484de37545b3569443f2ec666fee9ffbb698673bb829c099bfd8ee8dde3a5553b1e18be3567d3e55b0495829f2c300f0702346597c85eec1f285f1f28bedcae384cf534c22f072cbf03cf659f95d860da5f392291e62a24625f1671550f0db25c0fe0f73211e6d4fa8f30ddd73e4499116113ab238a5270a4e5a0d43cdbd4d2cbec17370a34b6752da955ab1abc5f1a05947d4be123dadeccd6d6f1dc0e4cb699aaeef191bb16c0b14cfb44d628391750324eedfbbd751a42bd21a72ab26f870ddfe497531552ed69b1e8e9e5a1f7747013bcc45a7740978acb5fc114e5591b69a03b469584f078303c3dbe2c14dfac40fa916d8e85ef6f01fc8b01fdb3c2abe5cba2c7af78724e4dc8e040a291e37901a6ead8af15912a013be348f708850cd8cf9922d5e4b6cef1607c3bc42a26c28ddc82782143fc095a8c29d0c1571e69abe964de130d425504865017b0f7cde44b889bea4da28f159a0b4bbf345332018b5dd994aa9f004839866e5e5a83a90a2fbcda603ab3cf9df7717911b32bb7b86e45662c5df232587c9b46c1a8b5c3412450985a12f7db0b15313066d90a972ac2a7f6c23252c012a43b2ca002ee13a1c7fe0957e86939ed1c95c8d07100758ba76fdaf844122e2d6b117000ca60ff430d9c6ba60027a6ca9f8a7e04ba1491c04bca589f1905b677d62dbe63382f077b378ab3ba5120021aedd23640476a92c44377837133e3ec005ae2f7ca85d290da030b411ccbf024b0161288c9bbbfea6efdc616835e5c4b936df68682d712732b517644e3b40258a133960c27e26163355223ba265430ff7fee16e719a58ed02a47e39254961d37e4cc167c62490c4780205657916acca40f06c160b7512d13dc3004e01b4baac7f468690da62118c681d61d3834a9c91e2521b1bbc2df7c695aa49373bdce66bd713535efac6e05b119eb1d3addf5ed75f7f82a01ef90cce260a564d17bb3fd7362016ade8d89f149a8826e199a29c207f130afd5326dc0e61840d33bf8a4b76cebd8618a8754383eb33c7ac96081510d736f5c40c8f32032c4f1f9da58a87596f57a412de110407e5d2cf14929e0e03a3451154c36e84fe628b7a4c1cdce45d8d5b3ea127a9c4b37a7df907232b6980066c71f0d09c2a943fb90eb16b00131ba0ece4f8eeb5ae46df67d40f1c944f13245604e83377879dfd5c1f481888a7ee1730a01b41075c7632d58d23d8cddd3db6db525220ce06a342148de1812b112004f11744c11d0f7287d2b4395acb06436b370d4505edfde4886ed1d0fca38b9ed015c0162007d3c7c66168283f7af860ee3b6d22438864d876820898887ae17d6c562bccaf0db8d22d71073aa17fca8129ccdf7db0c9b8a5e8fcb7ca040b0bbb6ba4bdb90e64a37b3c979c15738d1756d18a841f0a7bbed02ede7bd8806c1fbdc603bc646d51f96cbaec92d8b189796b360f336c4451f0b5016f126f0c19887ce61f011532a91513ee4e1f24e2843f792c585bc62b863ad82a41367e66a302bd4601088ac051b12ace95081822fcf9b86bdc7137448f12f43ea0668c6c9930221d1c69d8eec429895057d3d85ecdcdfa74e4a07d5c6e1989eb9838cc83375dc07e1bbf7ae476ceff11c2be93fabbd62ffddc34b27030b4635a1d7054b16a86bfe4c20598141904fff4731dd19c4a6de69ff493ac7f38fa01963913c0b0882cf44cd8b823d0e53f3cdc3cc952770960b0d9b0e3cbd79eaceaf1da2d1ccdcc496a3787a21f6ce6f579c83578961d0f586b0d20ddf516969c24a5dd94caa12c58b3f98285817ea8b6298ffe42ed6674e2ff2e3711140e6abdb192fe4e7f60677d2f506e996a609f47e1eea1f274744d6af028308f3e9c2083f6b27382380098175978dde4664d63afb50ebf14b482520a761a89b4949018340fa65f22111f520aa45ccd35e7938df30f54c89c818608c56a3266b4bb048a1fc315a634f1a2c0bb92d94357e909f1fbf4dfa3ed6c2f99cffec2ac9c1f564e62ed17fba6cbcdbf9c6590c8398ebcb8d810e68a9ba6bcb0ce01e881b7e5a8d3ab1902dc71d9d5715067ec299034ac0b86bcb08a77e5720dc86a03bd7e80fb61f91958db131ac2fbc4dcccd67813b20bbdfc60b83079ddfc678169c6abe1cbdf1a03bf0ad881d9d55c94056f6fbea38b5e3f1b06cd6ed9d5be7cedcbdd10901eca59c2a58a91fcc0eb095385b23c7e84a03151af55f8118f646795100dd83c6cbf71a1a4bd32760939a83b7e52e05ed6e5f4b97606c4fdf54679ce8e26d3eaf2f8e0fb254148039d0b4a1c0701a62eddedb29ee67deb2850646617fab6afb4555489fd2ac9234becee2a6134c131b44e29aec5006a6626069d7957fa99b77315ce505ab20f0d9d3996579ead6b3c8b786c501df452b4f39861418b9b0729d5e853df00f7de40f2a600639c65f284b415ecb7d523def700a9e48850019763e914ec180678d4eec4e63fd53590a8ce76c6119596a2e53cbbbd6e082a2eb26dc0777b41d3a0c2b227b63d8cb202bc2a6baebd23cb705b6d6ab489236dd134a818b29ec0d5748a15090ddbc6478da2a9d83cdb113180c0055d8086317c9e533d19a32bdd8ef47984c429a6298657e6ad8ccf8fddc89c1cd2e552cce9003cf8594d0a76dcc69d575cdf99e485e3fa5f35aec73d0539c4e73c9f8e396dfcfab8c11467a1629a4e39697288972f953feb5f4dce33427efbeaf071d57dcbcdfd4cc2247830878fdda5b6a7f9ace5194ef02bb1887cfd79f93953c3cb842a74a1f9193a54136bd8c86f31baaabf7dd92e5fffe967ed998edd8fe65508dd65770e462a072e854977683aa93c280ab6dfb7dba7757cc4e9cbfb09595bc336530b5d5c48347ded3377d467b875f556260dd1df7b6a6e5a640d9414b60102a55ce9d5626cd16cf473c7bf07c0edcee7eb8b407969f31dfb537b898771a4f8888a5c2f2a4d0414969a487ec288c63fa30fe7896ba129fc25358863c69c2947737eb621152719d106caf62ee01c86250e31248efe8a0705935ee9a1acb5707a7e91a900d8915592ae1664817f5e8aec326587210c6e9c90a9e7c95755434c66c22e9bc68c8f63d60855df195cac6665dfa7f4bac7ea0c7ab9cd55c1817075e8ce574a782c5cd0d9dae70ccdf45700bb54b492d86bf2ccea327088b2c5778c5ae4807abc593896d370745dd19c3a0e74d3baa13eeb03b0fe27d207893ef4248b04a0256232be0a50cee539f7070d70241d0f6bf194be0e503b369b2c0989a49d5a1fe83ea3e98baf82b75feff75d16204179eb5b9e9f34dad6dde8841bdb294a1ff79aa1f6aba8912aa2e0c4c502b91267467962dd37e1d673127ab5110bb9e03dad93506137949e56f888c2314b57977fc8c8d4a5ab624a43a2df3e4114d839e055db01aa3b9be75d370c25b3cb71f4c3f623daa99f6b58ee3f2bd1053529cf2e5cdfdcce51fdc2ec856f840ffe734562d952db55fb2160ce3f8137191df2c555268c0b3f5d259ce0532be0a71249c50ade7a2c77d0fb72925a254383135f6224452506f035d57be241995900ec18bbf2170a18d74e96911b3909578373b089f171a7733946b072fbc2071875294d12365d2d14addfe342791d4da9c1b3bfb80f27281a42f2a8cd0a5cb301d042b0f6b4585aa8c1deba221a5e7f74df7bfd656210387deac5e97bcb383623a3db828854b54b3b99718eedbccaad9afbe59a9fce68069097f65c71d1de6646e8965f2fb903a666b1933fb5da267d77abef7f4f8816d4fa207bfdb25980f973c2fa26e0655521be8c05e6915595720fb43400c9b0be3b500611784aff30291fc0cf08cefaca0a6f7e044ee44952cc60bf625b1b6ee6e488e203a3c0e0371addbf6b10ac5bdb65efe820aa66855291e94f83bb9812849d2226a4752ef88b47f17375e75c7940a55f856ed7dbea9e4fbd603f0e89e59ccafbdc07d72cb82da16990098cd2b931cce0bc4b348d9c7d3092da22971589a8c8862aa8d3bee882040d9e19cef59b4bb0f8500df70847b090b75e037c6843236475e62b243db43786e138b1585c070c222b9154132881dada00043b2d88a674c37350e739c50ef5b3da7d48d91a7e1fd6a7b58b884730387f8bd52b33375e70884594ed089975f5706ad9e311cd2e3143d3c271d4bb032cebf61b28c87980456552fab73d1844e07b8a0248d4f4fecf487e83fb555ebc96daf3015259ea7e0561c42dfb2a63cb810db1cc3bb8e19dde7e71d438b487fb38e244b76325846f21031002d796cdf9bc6c4156e19b7e627fd458afce6ae5e5d5a5cb904746208c080064c7f2536e20ff09895146d60277eb5b2fd1280d76c7733d3055b64e51c503ff299f093fc1eba53d264fd5ba155e8f1ae0801b7f3b20628b8cd4dca2bd722657d69fd6ad56c0bd5fb16865a2f86155cec5ad8439671b9735f9e381dc928a246452bb03bf4f0423d1b8cf5b0c5f1e0a1df6be7063d0732029a52dc63d7cad245d46402eff523616a48d72db8ead58a76217e641dc7467c55c59ea0a1214c7d3fbc185db9d42fb8e64ce0ec245aefaa1c5a35999d4e0b85b56ec71f17c6accf2278c3f8e0fd2aea885b7a6e86d54394599c031f0f8b603feb646652546b14384ed532724fbfeaac7b18483cccd789dc066e8345b5ebc05761b1b91c3f78364327e8a434bb50315e821ea93d2d3efbc25c5ef45b60d2f7bc00885d79e20fda5b248130d21cfc6cf542e7861dd60b62737921b14881bae1124cc26567e6b6b201b796567a422a385773b32eeb6ed5b0b2532e2ec8361dba4ae21cbdd034dac58e60ed3256107a223390d667ddd18ef1d459c6f3c21ba354a7563c823823d472a3fd0494ae68cf11a5f6056912698de3a0d37747e93075f737fcb77a7d0ace4361cf879007f8f8078a7c21682706270690917727ca09f442b59fa3330a97c29394ea72c2ff29c6a8e27061ba049d6d7080203bcad65adaef194edb48c3d842eed90c597e1a44cac2560f5afb91ea48bb43da74428053b02a84ba0f24320f7dba66bb86ee395c59168b77ce83ffa8d4ee7bb0fad0d0506f8a3eba2fe264fdf4f0df3aa4c8cd0a8461ff655dbd9d10e80b97d0bdcae9eaa2caf1690c32dd90a1408574b0c29c3261b5a6bdfaa4c90ab8bfcdd52ee24a6f20a169e7926a59d1f20e2e87f0e5667c16351090d745b2583e0c5b22348d7d649ac5efdd079c841246f3257c5de8f68952e94644309d638ff9a13ca428f7ef74dc268ec4bc295eeb89b68cd12b405df4a1c60e844b24cb7d238ba375fc7f2e516a3a5dd8b179c2d74c4afad68bac86152ef5298782dc433bfd7a47de23d44cd1408cabf99a3edfb9500b39304f305d05290331ba32c7d581c873915a6f037eedea0c205be20f0c8a824effd18eb6c861c91e8321c17ce9255775bdd63a4d5ddea190af034e6c2b41bb4ce6739ea77031414c38b47daef0d19f68a2d794a75afa6a50d2197d7db2dceaf43ce46b9eed64eb6341453d8928d612b042e043739e29782102fe097d77d7056be088caeb3826c895a6fa7701de1514a1704b91610f9cbd7a52b6bd320d256d938394ca92fe13a8a9d873f54367adf0a750867b5f50fcbd3a54239c3100ec828839e14538ebc19d3b4f9daf3023c9818f3ef5330cb3df51f83cb2ef220b52a9cc45c7c8f456308ac906b3f56785f918a41e85a3a0a6fcfc99f90410cb6495dc5aa1d331d5ec7c89c7bc2bac7a503b24db0cbe078e1b826cb24b3acb35d6889b818b674a3991f37496e1f5ce5c6526a041d5ef297d1dac60ba652a3cdb4eb19c47847e92ae20bb289598d07a361c5ab5deb91dbc4581b2bc576667390ad04fd292057424e031d1c492014b03ecdc228f53fad3d8c2779c1c8e321cb8faf619bfd1cf8a432559fc9a9b0496eb713fe9f699f13e97e815f83b63dca5e3bb9adfaad569630368eb9bb0e982af1379f306bc55e8e7eef9d1141f6b49f5d7bc8a5489ffcc279331c5af42b6da941a9150abbea748fdb0f451df5b06d5f9dc61abd5801407d5a0d8c3c6c8a11b9a02a6efbb247c615f6f6e2349ed6ad64f68417c1142d918534fc34274d7eeacd1e471b03a45ceb78db3007b59f6a2e13cbb993df97118a49bd7588c701b01c0143269f1573da6946fca9e1bed81af8eb841a846241466094f98b10cdb164ad9004edf16f36b59a2e4741fdff7b7bdee72a97f68e61ecf91c05f16c40ffc4e36b179c39b68e42ae5dabcdaf2769ce4f19c67e6916bfffde9f9715ca54025e7ac891461889621bb0a00b9f167dd1430d67bdce25a64df08bb3b0332a701443e422752a3e6936d7167db84f9c996a26fc1bf36e59ec7e2854bde5bced522f67f5e6a7e7fc0776d9602e4b4e3f1fbfa5286afc501ca61abdd3e1f5dc51688e9eb0151b2b90acbf4516981e09fda70d94c983dff88683fc6f0b73a3ea09e673082bd67f0bffc5d42f6500ddcbba59d97919112c875502bd008f9516401160f87ec39a19b53aee0d63275f60e8c80a8e2c33989525565ab1ffb6ec5b07712ef8c246eb0efeac53b07a09111839cfc7a770b0fbd23c7df0145e4645a2578362cb5e8e33ef343b4c527ee3c9ad24470ea2bce8111a0f5c21663ac2eea0cb7cf8ad094fe3fe5884760342f17225d6d11454fa1bb10ed3b6be7a69170ca1ec4bf8ed032fca9b91e40a9b5171861dc825a614c30bfd6c3cd418dec5ffeb01976e053b6caaa4801f7642ab2187fccb70fbabd28525232663c3f4fbe6e86968943e43166680c40ba4f74da81be2fdeec45d6af8a0d144c15649d6df9b1a27468c66349704802edc0bf61d19ad4505972a6cb0b36b209e28d9c6156f7c409d1c85d373abf876550b7bdd076fcfee012e0834a4d2fa0bf445107941162458060de0ae48d28766e2fce7ce19eee13507d7522d09bd5eb42c55bfcb4347b313f49c35b554b5d40fb77cb2eb01e7822af9d97ef03e7850e24d8939ad03146e5fa845a608513a72fbbd0f20fc98547ea0ef6deb248080f4e4dd82a5a78f45b38195eedf80240fb9990bc08d8d32ca4a84e7bf4ef48e7595e5920082bf34caef32101d6042016ba9780bc9214ad317be0c2fe78fb40b6fd1a2c3b12c517d3db49c160aaa44eced8699064c1ba80527cf67698765839645d24fa7294fd701f9daaca14b34e652ee9889fc4930d8e78307ca607dc81ee08172b81b62072cefe3714e478aa9ab95e17fe1ebcb99f0f62d7cab3372c40d2fb6a484bc3e650656dd1eacf991151e048bfbda1b220876fd83bdef2d5333f8491f3de468692a35d825a29fe1096df623e70286a09c3eac8acdc7d07dad009622613a09c8cbdaef0dd72ddac99d7ee55f68ee1fb94c68f71d8c39e757890e3a5fb5813d4474eb8d91bd4a41b37b95b5bf1baeccdf60de1603916714e78cd2b43d72bec34ed0e1b8abaa99816ea889b66b581f9c1419aa09beb029fc4803b742070590088c0e01a36f35dc2ebda368498c5c0501798364c1e8ee13e5f25d37de9e49e3c8cc70c56c2f373d00bd576adee58c822b5cce5d9a20bf02e1ae60aa7aafd4208ea54735a2d5df05d06a18679a36a4c3776191e62f30d09a59d5393294c7704047ff276772e5beddf1613a8f865317eb0504a73fa4b6832ec2340563817598af6283149ea46f8b2a1e881441aff9fe3cb1e605372d81c833f99cce28fed5835bf4f0fda445284b021c7c4953f57beb08c87e68d3d49d5dccea794adbc37f1a80204874480b1c71d075130b81f1f6903dc7e8d3f99e2277af8add802c62905fda66bded861acf04d58428b37db59d61b2e85b6561c35e0aeb9a227da257218f68549f121fa5bc771df4f25df92b6580999c8b73f063ec8758fc6b61efab5d93d10b3e60fd6236baa22c456e838e51b109373821212b4a758b94ffcef0b5a07745ba655824014c9de7d03b3d41e9bb267c2e132958631ec15828b5aa126b6272e87ff56370b861f6da45f96321e43dd201f4686f24cc996f107c60da0af8fb964b337866e57cece2a2da3f61932a7736120e119fc338a89683e1945dd43a9cc6688d4fb6c6c08e33b79125759e32fc0678cee9446bb2da9150ca9a4c98c28d87aff4d9d6180e3bd9f441afcc31a81fb177516d9175126b242faaed86141a0886baa7c98f4c737bff7cb1287f3e73a0fa90fa330d5365f1c29b1f1584d489e7ad432a5a9dd6e41fcf759b2c871ae4a7ea058db4fdfe94eb8d9f55e8f29e4b57d3e95dc8f4e61ab70c78abbd058f75c111b1ae4a09bd6f42757a0d5adb76cc2c9083fe0c58ccaff577c4cc44a1d007f4caa7333c2db6f3fa4ebfe4d9f4a81d420ee240aa5df2072355a1f5722457d1c05cba655e4c092af423ffc313c0e2d67a2b3fc9d61be73e801ab8aa909197d10a4ed929a9ac51fc7016446b4ed9dfe178b6d21fd4363a0c0d1d40c10aa6fe4d695709df09cd9906ffb219cbc276b553c50639fcaed89d011be9170383ce4b7d9562f4663c368477cee6ecb5aad21d24eeed7281096e6695133b4d5983d73799d1e14bc9f19abbc3134ddc58dad3e7411a46d1dedaacca7da02e2e9a6941a95de773f339a2e8e7d96b8fdceec9d32ce497b8743636bfdbd5f3e88d70647a95c0e66110171667a7bc2dc7cc1c777e756a0a1cd4a5a08e54fd6fae826992489234fd7cdde300da02838eda3f6c01e27d3ecb15cff96ee453263189521014e21110fa9b7c6316ba45ccc005ba3944b742ddf4bad10605cc484df849d46b6f89df3f740e3dcc951ee22712a09b869edfe24123317a3979d1a9953138f7bb1c6e5f3e0f6bdfff999b1a480265a843d9b92dcb632b03205413aae2bf54e3aa9492ff1cea71a3594c14cbf2154a380101e914369698d24d9908b7e1ef1f9e36fb56ed1a0b4e70325bd4ae51f294aae1e3befc7c2a64642def7a9dfb915d3bf3d316a722d51b085ea2c190e30a27c5e69eaf52bb104dbb8c29c833f478cd6b630924daf2402b2166150a4c8cbf684b0bea614a55b1a8c8a0be681312a36cbe940ed6d01e393cf3ff7702c5b36ff1618dd0639ccb353551b48fe542f44f19fd7d6333102dc68d167ad78d1a3716df1b2be68171b6157a260b4f0aac00c9765ed584fc52e6cc6415db80ad1226c5fa5b28483f8222bca6fe9bb4df5681a0c2778e0db3424e9517b316e167e9b2aa5604d2c8e82bd8b757ce9d84856420951f423c2e61c1594f80ca78ed0c2dc15029e408a6934e2ff2a4417a84dc15a3e3601a0fbb5a19c63bd0debc9d4f8320fcf9820f8148c48d883feb76ca029a5128ad0411e2f62ddd19ab7995fdd7f81eba5fcfd98f0b87c2400de8c54294fa3af9252de1d6d05c6f0c85d92f20396b4fdf0ec34a184f16b509475fb1cf6f391bb12a6eb10e1bb11695982c778248f28275405fe5c98ea72fb82737ba5afc9e355a55bc8524d7c9deff0bc3386e9ec19f0da95b3cf45f3de77db0645980ff123afec9049f304faa6d78c62a81ae8193a3f0a7181b84196ff34f6810460da6eef7b16966471a237bfb263a5523a932a0dbd0486ea2090b219511c1bfe6b0edef96aab358daccd50fdc8c27e7d2b7b6daff36785910c88db17e16dff2ddfb41655bb234b4c3050dc47bda727be0cd5f2d0a00dc6e7de617e85931651a0eeb45f7aaccb7446a25fca6767cca14282481ff4e36283f0e0444497c76816753d10d40336318e5bd53615074b33a5425b8ef7784a4cd5c945370b0c26b931f057289de801ecd08e2b47f0f75842f6335e889d897a7b3fae4711f4858dcacd5cc0461cfe2105caffd371a16d11e6517237776e8630ed05bc850b822a8316248583b0e28240c9aee24ab27ad7fa280cd43deda676d06c6f33de189b68d2de575979d4c19c5dd9d175133f46d02eed3d99ea4b2263e7a19adfc3859198141bc6111797526d57126073c0d0ca1d61827cb67500d44bed024aa805c2ca5e240777abf2d948d4eb47a75ff193a565032ffe94ea3a3203dbedb3d4d9234fde8d5ad621f0261f75d487fb91be5179ae70722c1ec0575a12bb52dc88ee160b965cda6cec453f5bb59935e6ea96143c2e1ca0a0cd77a6b699c0108a2404b9bf2f93f48fcdbfaf9075f57ccab7985579193b8836647d6e181ffda135de859b5179552b1d584229386e0ca6d3243e036ce1e1a5c904b68097f2dbf502a3e3baa46b8ae5eab03ccb76ad7967787ae0a891759f750e8dea59ef0db63833cb04b75048a0d29e4f4b43e32162fd303164713097aabc49a28e4365e7cf02b351bfaa25d838b3571d1d4297258174d37d2e85c14ee8a4bcf86daf0d7887192c59ecc3cf01c70c856bea061c536e92710dc0d303105bcd8911b16babe232660fbcb9536c690db69e21ddf6647d42288e4667973d6568b341a10779597818afa4d05a32979dbf6ab354b7dfc8894d4ef4b5f91a67e9e01ad230af20dcc5001cee219c74d354d7d60f72deebe7e877ee820f264e4220f762b09261f6f7e16e216f973f0c296507ec334210b0e0fad28c38460dce77b7ead4c83f7edf1ad5b37da0bbfbbec3468be661d3ea59ced8787e18fd5b6db94e9232098423e9f4a85b2af3ddbcd2c3d257b1158bb3f0157e2c6f9191d61453be663866d0987fb07cdfe46d33f679ccde59d3142ecbc2c6ff268a96a6ec6efdcffa5851c4440681bd8e2e64b89421d32ade2dbb5989535845161b19ad0a11874318c50bbbc1443205fe279a836e680a58af33182e25194708254d441fe20ce146a6f60beeedf5ea209f2ff40e56255d7f2e98ccacb6701857f1674a328b71b8511e81c146504186ca32166f1ed3a43a3ce27095e42a486943343d7a5639cbbffde4e84779cd0462ee56e3a87d2bf29fe520b813464b87e1a6e0922af5c74fd08a39dab59b132145c1dcea5cd2618e48be5b7ccb904fd47379903469465994f7df8e23710ee988d2feeccd324f984ffacc208660db7f0cc70e780626221fb3a5df6f239baf5ac2ef1d802bdd6c9122b422697fd4e21ab40857d082a8752bfe884ee093374a3d2101924a435911d2ebc8a0e9dc6d67e8819013cae8ecf0998ad5dce30c1de82a201993885575f8cee2006ca6abe275d2785b9312f71ed9196a72f96d2f7ffda1d2e8c36a23af20b2844351e0bb891341264c90ef1b5f38e0f4e223025db22342d3c8302b6cb14a150a46b45d6316146c8ff36a77940c86890fe97be170a738ab0fa5acb8eae3b8bf6aa05cdf894d4d3deb36e7e1a93d44b1bba651ce6fcbfe586eefc5fb5b198657829c52db0d9fc172ad27d507019992df6e848e00007b0181feee3cb1a1e0cc378c5cb2f2586ec10da3a6f6ba976dc7a32537c10a143c219c5813237d2ee1cf7bbfa3b4e2fe4e8befc3209b4d30fcc813eed823cfe24d479a24ea045c7d8212ed54e8570ad22a0b18bb0aa63ebbb83ecce9bb001f5411ba80a180dcd7388cf0f21d3709aa925a569ab7a7b7db4d5bc9782a901a3fe83c89e593078f785e03fcf8e3b76ccea52eb96a20bf2269b176fc106686f44ec08fc696a93bf83afd650cd7cfc87f6d76e3db58f997a6e4ae09477e908ac4c4264198e74dc18ddf6ead0ec1be4b0ae4029b1f45e5ef1a329ddbf8786aa724606e7e6301955f00e0d037aead8bad1a315eb14a4abff86254e7a31474690d06fdc7a0e18ea645209c1188a7e322d2bfcdf3190b70a7ce364e28985b51e8072cb31647a7eb95eab2f520a068a4205d6f11252dde89bfdfb45c12d62134b266f935e9ab2368b7646e947d5c35a69f61ab6e5b6df895da310b80e742940a3b5d5db97b3490d62582a5ec8afeb948bf1ebd1c1b814acfd00b896a2642b6d3f636f783fe2571b938c37f68e5a87bb977a98f94f6ce85036d48973a927cdee81b63dce5415865c7c262daa62b0269de7d8e1ca394cd013045c6afafc8d8bcf58c36388f2aaee134175bc64e7c9c95b9c7b3ddcf443e45bb88c81b2fac8329ce7dfac435eaa0e2942045ba14cfc2eb8a26c055bff0bcb3ffefba554de5228c6a84ae96339a38ffadf30677b0470b05fc49f3a426379bcfe39c472c2d0e38e27c73575c361fb60138ea22e5abd0babd13b3c4b51f115eb9219735dc6ff915515d708ecf88b28a890c1c8dde53d8105be9b9ed1093b22098c02e0701a69beb28c9034936bb467647da107dc8dfed074e8b6a95d85a07929ead8977ac2f3114b6f841760d4e40c1472dcd28437bba8deedc7574d0c43af785df4a2d298cce6124ba4dd245c5b99e56036dcf3148222894a0f4722d16d8c5e5d29d6f9d4cb98d8683c87c1b62c57a3437ed2265f46d6f63bbb12ca5a59f4eedfdc70fcf93ded5cd5493e5ebb9025036da71864e8e4f7a981c602a2a0ab4cf3a22c0d533a4ba67a21f502271e418500f6261f71d4e1b8d4df10c0bcc07bfcf0eab69926901053d4f1f08f55956f19118b2feb8748da5a302871e984aed220e6883fd1493ac02f4422d17b3c879e2fb928493ac7abb19b5d396e06fd98cb30c1d409224a4adabb4b358e000bad0a23acc4f5d73b670fca69e703344ef237e70bf135d4139bf92bd5c7d51568e8bb85cf265948a95b7a36a692a3bb9611c7e892567497ecae0ef406863c1311492be0fa51dc96006c22b9db8669e4acaf379fa131a682ed8862bea634ce94fa0ff79e2f34ced8a6595c9cf72d887776a1e01e0a4dba0630b1e8f14f8698278399a5d1e3fbb02e3f0d7617291630c85e11077906942c3a288dc04e7d54edbc4e66e94a7f13989c20603f88eebfb3137933fd9494f53f1361aeeda0b211962fbbd91ac6bda839ef82ca3fbe22a290196ad031189e99e98e81f57b65737a0f84eb65421379dfa29922d685b1c834091eee95c8fc6656f0b8efb583d9c40c1d5fe2fb8da8bba2a509ebfeb6182ab80272f396cd083d1b5d78b6182e8a01db6283899d193a02181220ce82865c99f03fa07636e6e71f40641bec5a11bd9b574ebba85e777539b2f87c4a968f533018e2a6d73feebd42327fe77bd453811a997bd64e7745dbb66d305d7602f1c84f597b31985fa39fac36c5c7d5c6c009bd8d32696b20856b943ed623c632ea0aaed21b28d372f3d9bbf86ae59d5da179906e7a82e56f193006e4d792861d81bffacb14dbc75a7cdd2534fea51f07c64c2ee2d2e62cb29deee1dfc606c8ac0effa007ebadea00bf5f4b2d53f1b34c58ff931117677bb841ea80c1c340e2cd108f981d46ab2c650e351ae0b46b15a25563fd5833a0d87384bbfa92e1757b8e4f6b254838c17bee1636cd9f24080bda6f6349a0c4566829de78aa17882a289de3ea142ccd285dfef927bdf96a29f9c0ce9ab18dfc54fda2bd6e2f1dc52bd731c757a62013a3f08e4f1735c02a1dd6434abd9b8de83df4d839bfd9d508baf2b3420479297f14c7bb8c7a677de047ff1a27b4dbafca0b1ecd39c93c0fd01d4d567409b0d7cbe8ae655a6e8a3441051a3b5c24aa5d19056dd13e692100fa232f0265e187b9220198596c6c83d905ed18795e9068beacdd94360ee0f18e515f52dc387cd8d62da753447d9a3b631bcd1e09aea048ac25e32c8375ffc38dcbf87b193c412addc7401d2337b805666aa32f6321c3d3e88cf8a387125f55e8456066f0ae56e1f3180f9c42d5fdde59f01ba0b4aeff4e6479da413ac8d7efb6144e8a8de88a3a520fcdaf877d752cbde9fb391c4019bc41f4ed82148a1302ad97fb2aefca1975969ee9880fa1fd3214d8c6cd228ace9151ca9c524781731b63dfb66946dd80075a6dc64d17292a351c37be311c4ed95eb49d1bce2cfe4c952202d9ef35a7ae9f3ba0c1d7a0f167a78ceedc9dd926565f10c2ecc4b1e36534c3eb322698197f6613769c2a38bfd06a6631273bab40b4092e760562662d5767655d343454d4d8e7d46f752c833811dfdc7ada0929b55","isRememberEnabled":true,"rememberDurationInDays":"30","staticryptSaltUniqueVariableName":"c6a255b0e0f82609d46969e7123189ab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
